"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataType = void 0;
const serdes_1 = require("./serdes");
const exposed_thing_1 = __importDefault(require("./exposed-thing"));
const consumed_thing_1 = __importDefault(require("./consumed-thing"));
const helpers_1 = __importDefault(require("./helpers"));
const logger_1 = require("./logger");
const content_serdes_1 = __importDefault(require("./content-serdes"));
const validation_1 = require("./validation");
const util_1 = require("util");
const { debug } = (0, logger_1.createLoggers)("core", "wot-impl");
class ThingDiscoveryProcess {
    constructor(directory, filter) {
        this.directory = directory;
        this.filter = filter;
        this.filter = filter;
        this.done = false;
    }
    async stop() {
        this.done = true;
    }
    async *[Symbol.asyncIterator]() {
        let rawThingDescriptions;
        try {
            const thingsPropertyOutput = await this.directory.readProperty("things");
            rawThingDescriptions = (await thingsPropertyOutput.value());
        }
        catch (error) {
            this.error = error instanceof Error ? error : new Error((0, util_1.inspect)(error));
            this.done = true;
            return;
        }
        for (const outputValue of rawThingDescriptions) {
            if (this.done) {
                return;
            }
            if (!(0, validation_1.isThingDescription)(outputValue)) {
                this.error = (0, validation_1.getLastValidationErrors)();
                continue;
            }
            yield outputValue;
        }
        this.done = true;
    }
}
class WoTImpl {
    constructor(srv) {
        this.srv = srv;
    }
    async discover(filter) {
        throw new Error("not implemented");
    }
    async exploreDirectory(url, filter) {
        const directoryThingDescription = await this.requestThingDescription(url);
        const consumedDirectory = await this.consume(directoryThingDescription);
        return new ThingDiscoveryProcess(consumedDirectory, filter);
    }
    async requestThingDescription(url) {
        const uriScheme = helpers_1.default.extractScheme(url);
        const client = this.srv.getClientFor(uriScheme);
        const content = await client.requestThingDescription(url);
        const value = content_serdes_1.default.contentToValue({ type: content.type, body: await content.toBuffer() }, {});
        if ((0, validation_1.isThingDescription)(value)) {
            return value;
        }
        throw (0, validation_1.getLastValidationErrors)();
    }
    async consume(td) {
        try {
            const thing = (0, serdes_1.parseTD)(JSON.stringify(td), true);
            const newThing = new consumed_thing_1.default(this.srv, thing);
            debug(`WoTImpl consuming TD ${newThing.id != null ? `'${newThing.id}'` : "without id"} to instantiate ConsumedThing '${newThing.title}'`);
            return newThing;
        }
        catch (err) {
            throw new Error(`Cannot consume TD because ${err instanceof Error ? err.message : err}`);
        }
    }
    produce(init) {
        return new Promise((resolve, reject) => {
            try {
                const validated = helpers_1.default.validateExposedThingInit(init);
                if (!validated.valid) {
                    throw new Error("Thing Description JSON schema validation failed:\n" + validated.errors);
                }
                const newThing = new exposed_thing_1.default(this.srv, init);
                debug(`WoTImpl producing new ExposedThing '${newThing.title}'`);
                if (this.srv.addThing(newThing)) {
                    resolve(newThing);
                }
                else {
                    throw new Error("Thing already exists: " + newThing.title);
                }
            }
            catch (err) {
                reject(new Error(`Cannot produce ExposedThing because " + ${err instanceof Error ? err.message : err}`));
            }
        });
    }
}
exports.default = WoTImpl;
var DataType;
(function (DataType) {
    DataType["boolean"] = "boolean";
    DataType["number"] = "number";
    DataType["integer"] = "integer";
    DataType["string"] = "string";
    DataType["object"] = "object";
    DataType["array"] = "array";
    DataType["null"] = "null";
})(DataType || (exports.DataType = DataType = {}));
//# sourceMappingURL=wot-impl.js.map